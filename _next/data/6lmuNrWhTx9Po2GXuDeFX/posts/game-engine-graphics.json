{"pageProps":{"postData":{"id":"game-engine-graphics","content":"<p>Welcome to part 1 of making a game engine. In this part, we will be drawing some graphics.</p>\n<iframe width=\"100%\" height=\"333\" src=\"https://www.youtube.com/embed/CHpcG1VSH0E\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p>But first, we need to understand today's graphics hardware. Today, we use GPUs, which stands for Graphics Processing Units. These are specialized processors designed for drawing graphics.\r\n<img src=\"/images/game-engine-graphics/gpu-list.png\" alt=\"\">\r\nThere's a wide range of these GPUs that have different features and architectures.</p>\n<p><img src=\"/images/game-engine-graphics/1980s-computers.png\" alt=\"\"></p>\n<p>In the 1980s, there was a smaller range of GPUs available and developers would write code for the hardware that they would support. However, this turned into an issue in 1994. The Lion King Game came out with many drivers for different types of computers. The game has issues with Compaq computers. Causing Disney's support to be flooded with issues with the game, and parents were given a CD with v1.1 that included better support for more hardware.</p>\n<p><img src=\"/images/game-engine-graphics/doom-95.jpg\" alt=\"\"></p>\n<p>Microsoft recognized this as a limitation of Windows and created DirectX as a solution. The first game using DirectX being Doom 95 with Gabe Newell being the one who started porting the game over to Windows.\r\n<img src=\"/images/game-engine-graphics/xbox-console.png\" alt=\"\">\r\nMicrosoft would also develop a custom version of Windows CE for the Sega Dreamcast with DirectX and would later use DirectX to form the basis of Microsoft's Xbox game console.</p>\n<div style='position:relative; padding-bottom:calc(56.25% + 44px)'><iframe src='https://gfycat.com/ifr/SparseWhiteBronco' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div>\n<p>In case, you aren't aware, APIs, short for Application Programming Interfaces, give applications a way to interact with something. For example, a game can sent GPU instructions to DirectX and DirectX would translate that into something that the GPU understands. Examples of a graphics API include OpenGL, Vulkan, and DirectX.</p>\n<div style='position:relative; padding-bottom:calc(56.25% + 44px)'><iframe src='https://gfycat.com/ifr/ChillyNegativeBunting' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div>\n<p>These APIs are designed with 3D graphics in mind, but the same functionality can be used for 2D graphics. For example, the game above look like it's in 2D, but you can rotate the camera, and in motion, you can see that there's a third dimension.</p>\n<p>Many developers don't use these APIs, at least not directly. Game engines like Unity usually handle this for you. However, without a game engine, you can use rendering libraries to handle the different graphics APIs for you.\r\nExamples include BGFX, three.js, and Filament.</p>\n<div style='position:relative; padding-bottom:calc(56.25% + 44px)'><iframe src='https://gfycat.com/ifr/PointlessJovialGyrfalcon' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div>\n<p>Triangles are commonly used as the basic building blocks for graphics. Triangles can be connected together to make more complex shapes that we'll call polygon meshes.</p>\n<p><img src=\"/images/game-engine-graphics/Texture_mapping_demonstration_animation.gif\" alt=\"\">\r\nYou can use images to get smaller details on the surfaces of triangles. This is known as texture mapping. To get this to work, not only do you need the image, but each point or vertex in the polygon mesh needs to be mapped like locations on a treasure map. This map is known as the UV map.</p>\n<p><img src=\"/images/game-engine-graphics/threejs-materials.jpg\" alt=\"\">\r\n<a href=\"https://threejs.org/examples/?#webgl_materials\">https://threejs.org/examples/#webgl_materials</a></p>\n<p>You may also change how light reacts to a triangle's surface using materials. You can create materials using shaders or code for the GPU is run with numbers or textures as inputs.</p>\n<p><img src=\"/images/game-engine-graphics/threejs-standard-material.jpg\" alt=\"\">\r\n<a href=\"https://threejs.org/examples/#webgl_materials_variations_standard\">https://threejs.org/examples/#webgl_materials_variations_standard</a></p>\n<p><img src=\"/images/game-engine-graphics/compass-enlarged.webp\" alt=\"\"></p>\n<p>As an example, let's recreate the Minecraft compass and spin its needle.</p>\n<pre><code class=\"language-ts\">import * as three from 'three';\n</code></pre>\n<p>First, I chose to use three.js for rendering, TypeScript as the programming language, and WebPack. To set up your tools, you'll need to install node.js, NPM, and the following packages: typescript @types/three webpack webpack-cli webpack-dev-server. You'll then need to set up TypeScript and WebPack, but I personally just used a template I found online.</p>\n<pre><code class=\"language-ts\">this.scene = new three.Scene();\r\nthis.scene.background = new three.Color(\"gray\");\n</code></pre>\n<p>Now, create a scene, where we'll place any lights, cameras, and objects. We'll also set the background color to gray. A colored background is useful for when the scene isn't working.</p>\n<pre><code class=\"language-ts\">this.camera = new three.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);\r\nthis.camera.position.z = 500;\n</code></pre>\n<p>The scene shouldn't be gray just yet, as a scene needs a camera.</p>\n<div style='position:relative; padding-bottom:calc(56.25% + 44px)'><iframe src='https://gfycat.com/ifr/ObviousInsidiousKestrel' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div>\n<p>There are 2 types you can choose from, perspective and orthographic.</p>\n<p><img src=\"/images/game-engine-graphics/20211116174802_1.jpg\" alt=\"\">\r\nPerspective projection in Portal 2</p>\n<p><img src=\"/images/game-engine-graphics/IV_area2_back.PNG.png\" alt=\"\">\r\nOrthographic projection in Monument Valley</p>\n<p>With perspective projection, objects will appear smaller when they are farther away from the camera. Orthographic projection doesn't do this, and instead things will appear the same size no matter the distance away from the camera.</p>\n<pre><code class=\"language-ts\">//create the renderer\r\nthis.renderer = new three.WebGLRenderer();\r\nthis.renderer.setPixelRatio(window.devicePixelRatio);\r\ndocument.body.appendChild(this.renderer.domElement);\r\n\r\n//start animating\r\nthis.animate = this.animate.bind(this);\r\nwindow.requestAnimationFrame(this.animate);\n</code></pre>\n<pre><code class=\"language-ts\">animate() {\r\n    window.requestAnimationFrame(this.animate);\r\n\r\n    this.renderer.render(this.scene, this.camera);\r\n}\n</code></pre>\n<p>We'll create a loop that'll animate our compass. In the loop, you call the renderer's render function and give it the scene and camera.</p>\n<p><img src=\"/images/game-engine-graphics/gray_1.52.1.jpg\" alt=\"\">\r\nDoing this correctly should give you a gray output.</p>\n<pre><code class=\"language-ts\">const meshPromise = new Promise&#x3C;three.Mesh>((resolve, reject) => {\r\n    new three.TextureLoader().load('compass.png', (texture) => {\r\n        const geometry = new three.PlaneGeometry(600, 600);\r\n        const material = new three.MeshBasicMaterial( {map: texture } );\r\n\r\n        var mesh = new three.Mesh(geometry, material);\r\n\r\n        this.scene.add(mesh);\r\n        resolve(mesh);\r\n    })\r\n});\n</code></pre>\n<p>Now let's load in our mesh. <a href=\"/images/game-engine-graphics/compass.png\">This is the texture file that we'll be using.</a> Loading a texture from a file will take an unknown amount of time, so you'll want to have it done in the background. The geometry and the material also needs to be defined. That'll be a plane, and the material should just output the color of our texture. Create the mesh using the geometry and material and add it to the sense.</p>\n<p><img src=\"/images/game-engine-graphics/load-mesh_1.56.1.jpg\" alt=\"\">\r\nYou should get a strange looking texture as a result.</p>\n<p>This is because the texture is repeated many times on the texture, and it mapped the corners of the tall image to the corners of our square.</p>\n<pre><code class=\"language-ts\">texture.repeat.set(1, 1/2);\n</code></pre>\n<p><img src=\"/images/game-engine-graphics/half-repeat_1.57.1.jpg\" alt=\"\"></p>\n<p>To fix this, I set the texture's repeat vector. This allows textures to be repeated many times, but you can use a fraction to zoom in on the texture.</p>\n<div style='position:relative; padding-bottom:calc(56.25% + 44px)'><iframe src='https://gfycat.com/ifr/DangerousFoolhardyBadger' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div>\n<pre><code class=\"language-ts\">const frameSize: number = 16/512; // same as 1/32\r\ntexture.repeat.set(1, this.frameSize);\n</code></pre>\n<p>So, on the y-axis, we use 1 over how many times the compass is repeated on the texture.</p>\n<p><img src=\"/images/game-engine-graphics/set-repeat_1.58.1.jpg\" alt=\"\">\r\nThe result should be a blurry compass.</p>\n<p><img src=\"/images/game-engine-graphics/compass.jpg\" alt=\"\">\r\nThe compass in Minecraft isn't blurry, it's pixelated.</p>\n<pre><code class=\"language-ts\">texture.magFilter = three.NearestFilter;\n</code></pre>\n<p>To get the same effect, change the magnification filter.</p>\n<p><img src=\"/images/game-engine-graphics/magnification_1.62.1.jpg\" alt=\"\">\r\nThe magnification handles texture pixels that are bigger or the same size as a pixel on the screen.\r\n<img src=\"/images/game-engine-graphics/linear-mag_2.15.1.jpg\" alt=\"\">\r\nThe default is usually linear, which uses an average of the 4 closest pixels on the texture.\r\n<img src=\"/images/game-engine-graphics/nearest-mag_2.16.1.jpg\" alt=\"\">\r\nTo get the pixelated effect, we want to use the nearest pixel on the texture.</p>\n<p><img src=\"/images/game-engine-graphics/set-meg-filter_1.66.1.jpg\" alt=\"\">\r\nResulting in a pixelated compass.</p>\n<pre><code class=\"language-ts\">material.alphaTest = 0.5;\n</code></pre>\n<p>Let's also remove the black background around the compass.</p>\n<p><img src=\"/images/game-engine-graphics/color-picker_1.74.1.jpg\" alt=\"\">\r\nEach pixel on the compass texture has 4 values, red, green, blue, and alpha. The alpha value goes from 0 for transparent, 1 for opaque, and around 0.5 for translucent.\r\n<img src=\"/images/game-engine-graphics/opacity_1.67.1.jpg\" alt=\"\">\r\nFor translucent material, they are given special treatment that lets them blend in with objects that are behind it. However, this blending can be slower to render and for this texture, the alpha values on this texture are either 0 or 1 because of nearest filtering. So, it makes sense for us to use an alpha text instead. Using an alpha test, makes the renderer ignore parts of the material where the alpha value is larger than the alpha test.</p>\n<p><img src=\"/images/game-engine-graphics/alpha-test_1.78.1.jpg\" alt=\"\">\r\nNow you should see a compass on a gray background.</p>\n<pre><code class=\"language-ts\">this.frameNum += 1;\r\n(mesh.material as three.MeshBasicMaterial)?.map.offset.set(0, 1 - this.frameSize * this.frameNum);\r\nconst frameCount = 512/16;\r\nthis.frameNum = this.frameNum % frameCount;\n</code></pre>\n<p>With all that out of the way, let's start animating the compass.\r\n<img src=\"/images/game-engine-graphics/bottom-frame_2.20.1.jpg\" alt=\"\">\r\nIf you look at which frame of the compass if being rendered, it's the one at the very bottom of the image.\r\n<img src=\"/images/game-engine-graphics/0-uv_2.21.1.jpg\" alt=\"\">\r\nThis is because 0 in our UV map is on the bottom left.</p>\n<div style='position:relative; padding-bottom:calc(56.25% + 44px)'><iframe src='https://gfycat.com/ifr/SelfishAgonizingAllensbigearedbat' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div>\n<p>So, using an offset of 1 - 1/32 gives the first frame. The 2nd frame would be 1 - (1/32 * 2). Giving us the formula 1 - (frameSize * frameNum), with frameNum being set to frameNum + 1 every time we render. You might also need to loop the frameNum back to 1, when it gets higher than the number of frames available, to allow for a looping animation and this can be done with % or modulo.</p>\n<div style='position:relative; padding-bottom:calc(56.25% + 44px)'><iframe src='https://gfycat.com/ifr/FlimsyGaseousChanticleer' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div>\n<p>And we're done. <a href=\"https://github.com/yourWaifu/game-engine/blob/16f7d3059797f87ea6351b755cd719f38f48c97f/js/index.ts\">Here's the final code.</a></p>\n<p>If you have any question, please feel free to do so in the comments. I'll make a part 2 if this content becomes successful and has lots of likes or claps.</p>\n","layout":"article","title":"Video Game Graphics - Make a Game Engine","description":null,"author":"Hao Qi Wu","date":"Mon Nov 29 2021 22:30:00 GMT+0000 (Coordinated Universal Time)"}},"__N_SSG":true}