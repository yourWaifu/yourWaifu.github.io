<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Video Game Graphics - Make a Game Engine</title><link rel="preload" href="/images/game-engine-graphics/gpu-list.png" as="image" fetchpriority="high"/><meta name="next-head-count" content="10"/><link rel="preload" href="/_next/static/css/9a4b0f5ce79e080b.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/9a4b0f5ce79e080b.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/ee531a15804ab5f0.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/ee531a15804ab5f0.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-70f3bcf14ec27c00.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-28fb632452810d26.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-145f833db83c1e47.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-76502e455de2e558.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/733-be30f874b9528e73.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-f11c6f829efd1b32.js" defer="" crossorigin=""></script><script src="/_next/static/36ahIlKQJ3GJD0QPJ4a2T/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/36ahIlKQJ3GJD0QPJ4a2T/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><main style="top:0;left:0;right:0;bottom:0;position:absolute"><article class="__className_af7b73"><section class="article-header"><section class="article-header-flex-section"><ul class="__className_29b66e article-header-flex" style="width:fit-content"><li><a href="/"><h1 class="__className_29b66e">yourWaifu</h1></a></li></ul><ul class="article-header-flex right-menu"><li><a href="https://github.com/yourWaifu" aria-label="GitHub"><i class="fab fa-github fa-2x"></i></a></li></ul></section><section class="article-header-info"><h1 class="__className_29b66e article-header-title">Video Game Graphics - Make a Game Engine</h1><div><p>written on <!-- -->Nov 29, 2021<!-- --> by Hao Qi Wu</p></div></section></section><div class="article"><section class="article-content"><p>Welcome to part 1 of making a game engine. In this part, we will be drawing some graphics.</p>
<a href="https://youtube.com/watch?v=CHpcG1VSH0E">YouTube Link</a>
<p>But first, we need to understand today&#x27;s graphics hardware. Today, we use GPUs, which stands for Graphics Processing Units. These are specialized processors designed for drawing graphics.</p>
<img alt="" fetchpriority="high" width="1903" height="1063" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/gpu-list.png"/>
<p>There&#x27;s a wide range of these GPUs that have different features and architectures.</p>
<img alt="" loading="lazy" width="1920" height="1080" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/1980s-computers.png"/>
<p>In the 1980s, there was a smaller range of GPUs available and developers would write code for the hardware that they would support. However, this turned into an issue in 1994. The Lion King Game came out with many drivers for different types of computers. The game has issues with Compaq computers. Causing Disney&#x27;s support to be flooded with issues with the game, and parents were given a CD with v1.1 that included better support for more hardware.</p>
<img alt="" loading="lazy" width="1004" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/doom-95.jpg"/>
<p>Microsoft recognized this as a limitation of Windows and created DirectX as a solution. The first game using DirectX being Doom 95 with Gabe Newell being the one who started porting the game over to Windows.</p>
<img alt="" loading="lazy" width="1245" height="813" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/xbox-console.png"/>
<p>Microsoft would also develop a custom version of Windows CE for the Sega Dreamcast with DirectX and would later use DirectX to form the basis of Microsoft&#x27;s Xbox game console.</p>
<p>In case, you aren&#x27;t aware, APIs, short for Application Programming Interfaces, give applications a way to interact with something. For example, a game can sent GPU instructions to DirectX and DirectX would translate that into something that the GPU understands. Examples of a graphics API include OpenGL, Vulkan, and DirectX.</p>
<p>These APIs are designed with 3D graphics in mind, but the same functionality can be used for 2D graphics. For example, the game above look like it&#x27;s in 2D, but you can rotate the camera, and in motion, you can see that there&#x27;s a third dimension.</p>
<p>Many developers don&#x27;t use these APIs, at least not directly. Game engines like Unity usually handle this for you. However, without a game engine, you can use rendering libraries to handle the different graphics APIs for you.
Examples include BGFX, three.js, and Filament.</p>
<video controls="" loop="" width="100%"><source src="/images/game-engine-graphics/PointlessJovialGyrfalcon-mobile.mp4" type="video/mp4"/></video>
<p>Triangles are commonly used as the basic building blocks for graphics. Triangles can be connected together to make more complex shapes that we&#x27;ll call polygon meshes.</p>
<img alt="" loading="lazy" width="256" height="256" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/Texture_mapping_demonstration_animation.gif"/>
<p>You can use images to get smaller details on the surfaces of triangles. This is known as texture mapping. To get this to work, not only do you need the image, but each point or vertex in the polygon mesh needs to be mapped like locations on a treasure map. This map is known as the UV map.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/threejs-materials.jpg"/>
<p><a href="https://threejs.org/examples/?#webgl_materials">three.js example materials</a></p>
<p>You may also change how light reacts to a triangle&#x27;s surface using materials. You can create materials using shaders or code for the GPU is run with numbers or textures as inputs.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/threejs-standard-material.jpg"/>
<p><a href="https://threejs.org/examples/#webgl_materials_variations_standard">three.js example materials variations</a></p>
<img alt="" loading="lazy" width="2160" height="2160" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/compass-enlarged.webp"/>
<p>As an example, let&#x27;s recreate the Minecraft compass and spin its needle.</p>
<pre><code class="language-ts">import * as three from &#x27;three&#x27;;
</code></pre>
<p>First, I chose to use three.js for rendering, TypeScript as the programming language, and WebPack. To set up your tools, you&#x27;ll need to install node.js, NPM, and the following packages: typescript @types/three webpack webpack-cli webpack-dev-server. You&#x27;ll then need to set up TypeScript and WebPack, but I personally just used a template I found online.</p>
<pre><code class="language-ts">this.scene = new three.Scene();
this.scene.background = new three.Color(&quot;gray&quot;);
</code></pre>
<p>Now, create a scene, where we&#x27;ll place any lights, cameras, and objects. We&#x27;ll also set the background color to gray. A colored background is useful for when the scene isn&#x27;t working.</p>
<pre><code class="language-ts">this.camera = new three.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
this.camera.position.z = 500;
</code></pre>
<p>The scene shouldn&#x27;t be gray just yet, as a scene needs a camera.</p>
<video controls="" loop="" width="100%"><source src="/images/game-engine-graphics/ObviousInsidiousKestrel-mobile.mp4" type="video/mp4"/></video>
<p>There are 2 types you can choose from, perspective and orthographic.</p>
<img alt="" loading="lazy" width="1920" height="1080" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/20211116174802_1.jpg"/>
<p>Perspective projection in Portal 2</p>
<img alt="" loading="lazy" width="2048" height="2732" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/IV_area2_back.PNG.png"/>
<p>Orthographic projection in Monument Valley</p>
<p>With perspective projection, objects will appear smaller when they are farther away from the camera. Orthographic projection doesn&#x27;t do this, and instead things will appear the same size no matter the distance away from the camera.</p>
<pre><code class="language-ts">//create the renderer
this.renderer = new three.WebGLRenderer();
this.renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(this.renderer.domElement);

//start animating
this.animate = this.animate.bind(this);
window.requestAnimationFrame(this.animate);
</code></pre>
<pre><code class="language-ts">animate() {
    window.requestAnimationFrame(this.animate);

    this.renderer.render(this.scene, this.camera);
}
</code></pre>
<p>We&#x27;ll create a loop that&#x27;ll animate our compass. In the loop, you call the renderer&#x27;s render function and give it the scene and camera.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/gray_1.52.1.jpg"/>
<p>Doing this correctly should give you a gray output.</p>
<pre><code class="language-ts">const meshPromise = new Promise&lt;three.Mesh&gt;((resolve, reject) =&gt; {
    new three.TextureLoader().load(&#x27;compass.png&#x27;, (texture) =&gt; {
        const geometry = new three.PlaneGeometry(600, 600);
        const material = new three.MeshBasicMaterial( {map: texture } );

        var mesh = new three.Mesh(geometry, material);

        this.scene.add(mesh);
        resolve(mesh);
    })
});
</code></pre>
<p>Now let&#x27;s load in our mesh. <a href="/images/game-engine-graphics/compass.png">This is the texture file that we&#x27;ll be using.</a> Loading a texture from a file will take an unknown amount of time, so you&#x27;ll want to have it done in the background. The geometry and the material also needs to be defined. That&#x27;ll be a plane, and the material should just output the color of our texture. Create the mesh using the geometry and material and add it to the sense.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/load-mesh_1.56.1.jpg"/>
<p>You should get a strange looking texture as a result.</p>
<p>This is because the texture is repeated many times on the texture, and it mapped the corners of the tall image to the corners of our square.</p>
<pre><code class="language-ts">texture.repeat.set(1, 1/2);
</code></pre>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/half-repeat_1.57.1.jpg"/>
<p>To fix this, I set the texture&#x27;s repeat vector. This allows textures to be repeated many times, but you can use a fraction to zoom in on the texture.</p>
<video controls="" loop="" width="100%"><source src="/images/game-engine-graphics/DangerousFoolhardyBadger-mobile.mp4" type="video/mp4"/></video>
<pre><code class="language-ts">const frameSize: number = 16/512; // same as 1/32
texture.repeat.set(1, this.frameSize);
</code></pre>
<p>So, on the y-axis, we use 1 over how many times the compass is repeated on the texture.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/set-repeat_1.58.1.jpg"/>
<p>The result should be a blurry compass.</p>
<img alt="" loading="lazy" width="16" height="512" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/compass.jpg"/>
<p>The compass in Minecraft isn&#x27;t blurry, it&#x27;s pixelated.</p>
<pre><code class="language-ts">texture.magFilter = three.NearestFilter;
</code></pre>
<p>To get the same effect, change the magnification filter.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/magnification_1.62.1.jpg"/>
<p>The magnification handles texture pixels that are bigger or the same size as a pixel on the screen.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/linear-mag_2.15.1.jpg"/>
<p>The default is usually linear, which uses an average of the 4 closest pixels on the texture.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/nearest-mag_2.16.1.jpg"/>
<p>To get the pixelated effect, we want to use the nearest pixel on the texture.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/set-meg-filter_1.66.1.jpg"/>
<p>Resulting in a pixelated compass.</p>
<pre><code class="language-ts">material.alphaTest = 0.5;
</code></pre>
<p>Let&#x27;s also remove the black background around the compass.</p>
<img alt="" loading="lazy" width="1280" height="606" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/color-picker_1.74.1.jpg"/>
<p>Each pixel on the compass texture has 4 values, red, green, blue, and alpha. The alpha value goes from 0 for transparent, 1 for opaque, and around 0.5 for translucent.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/opacity_1.67.1.jpg"/>
<p>For translucent material, they are given special treatment that lets them blend in with objects that are behind it. However, this blending can be slower to render and for this texture, the alpha values on this texture are either 0 or 1 because of nearest filtering. So, it makes sense for us to use an alpha text instead. Using an alpha test, makes the renderer ignore parts of the material where the alpha value is larger than the alpha test.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/alpha-test_1.78.1.jpg"/>
<p>Now you should see a compass on a gray background.</p>
<pre><code class="language-ts">this.frameNum += 1;
(mesh.material as three.MeshBasicMaterial)?.map.offset.set(0, 1 - this.frameSize * this.frameNum);
const frameCount = 512/16;
this.frameNum = this.frameNum % frameCount;
</code></pre>
<p>With all that out of the way, let&#x27;s start animating the compass.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/bottom-frame_2.20.1.jpg"/>
<p>If you look at which frame of the compass if being rendered, it&#x27;s the one at the very bottom of the image.</p>
<img alt="" loading="lazy" width="1280" height="720" decoding="async" data-nimg="1" style="color:transparent" src="/images/game-engine-graphics/0-uv_2.21.1.jpg"/>
<p>This is because 0 in our UV map is on the bottom left.</p>
<video controls="" loop="" width="100%"><source src="/images/game-engine-graphics/SelfishAgonizingAllensbigearedbat-mobile.mp4" type="video/mp4"/></video>
<p>So, using an offset of 1 - 1/32 gives the first frame. The 2nd frame would be 1 - (1/32 * 2). Giving us the formula 1 - (frameSize * frameNum), with frameNum being set to frameNum + 1 every time we render. You might also need to loop the frameNum back to 1, when it gets higher than the number of frames available, to allow for a looping animation and this can be done with % or modulo.</p>
<video controls="" loop="" width="100%"><source src="/images/game-engine-graphics/FlimsyGaseousChanticleer-mobile.mp4" type="video/mp4"/></video>
<p>And we&#x27;re done. <a href="https://github.com/yourWaifu/game-engine/blob/16f7d3059797f87ea6351b755cd719f38f48c97f/js/index.ts">Here&#x27;s the final code.</a></p>
<p>If you have any question, please feel free to do so in the comments. I&#x27;ll make a part 2 if this content becomes successful and has lots of likes or claps.</p></section></div></article></main><noscript></noscript></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"game-engine-graphics","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {YouTube, Image} = _components;\n  if (!Image) _missingMdxReference(\"Image\", true);\n  if (!YouTube) _missingMdxReference(\"YouTube\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Welcome to part 1 of making a game engine. In this part, we will be drawing some graphics.\"\n    }), \"\\n\", _jsx(YouTube, {\n      videoId: \"CHpcG1VSH0E\",\n      opts: {\n        width: '100%',\n        height: 'auto'\n      }\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But first, we need to understand today's graphics hardware. Today, we use GPUs, which stands for Graphics Processing Units. These are specialized processors designed for drawing graphics.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/gpu-list.png\",\n      alt: \"\",\n      width: 1903,\n      height: 1063,\n      priority: true\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There's a wide range of these GPUs that have different features and architectures.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/1980s-computers.png\",\n      alt: \"\",\n      width: 1920,\n      height: 1080\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the 1980s, there was a smaller range of GPUs available and developers would write code for the hardware that they would support. However, this turned into an issue in 1994. The Lion King Game came out with many drivers for different types of computers. The game has issues with Compaq computers. Causing Disney's support to be flooded with issues with the game, and parents were given a CD with v1.1 that included better support for more hardware.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/doom-95.jpg\",\n      alt: \"\",\n      width: 1004,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Microsoft recognized this as a limitation of Windows and created DirectX as a solution. The first game using DirectX being Doom 95 with Gabe Newell being the one who started porting the game over to Windows.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/xbox-console.png\",\n      alt: \"\",\n      width: 1245,\n      height: 813\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Microsoft would also develop a custom version of Windows CE for the Sega Dreamcast with DirectX and would later use DirectX to form the basis of Microsoft's Xbox game console.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In case, you aren't aware, APIs, short for Application Programming Interfaces, give applications a way to interact with something. For example, a game can sent GPU instructions to DirectX and DirectX would translate that into something that the GPU understands. Examples of a graphics API include OpenGL, Vulkan, and DirectX.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"These APIs are designed with 3D graphics in mind, but the same functionality can be used for 2D graphics. For example, the game above look like it's in 2D, but you can rotate the camera, and in motion, you can see that there's a third dimension.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Many developers don't use these APIs, at least not directly. Game engines like Unity usually handle this for you. However, without a game engine, you can use rendering libraries to handle the different graphics APIs for you.\\r\\nExamples include BGFX, three.js, and Filament.\"\n    }), \"\\n\", _jsx(\"video\", {\n      controls: true,\n      loop: true,\n      width: \"100%\",\n      children: _jsx(\"source\", {\n        src: \"/images/game-engine-graphics/PointlessJovialGyrfalcon-mobile.mp4\",\n        type: \"video/mp4\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Triangles are commonly used as the basic building blocks for graphics. Triangles can be connected together to make more complex shapes that we'll call polygon meshes.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/Texture_mapping_demonstration_animation.gif\",\n      alt: \"\",\n      width: 256,\n      height: 256\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can use images to get smaller details on the surfaces of triangles. This is known as texture mapping. To get this to work, not only do you need the image, but each point or vertex in the polygon mesh needs to be mapped like locations on a treasure map. This map is known as the UV map.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/threejs-materials.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://threejs.org/examples/?#webgl_materials\",\n        children: \"three.js example materials\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You may also change how light reacts to a triangle's surface using materials. You can create materials using shaders or code for the GPU is run with numbers or textures as inputs.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/threejs-standard-material.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://threejs.org/examples/#webgl_materials_variations_standard\",\n        children: \"three.js example materials variations\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/compass-enlarged.webp\",\n      alt: \"\",\n      width: 2160,\n      height: 2160\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As an example, let's recreate the Minecraft compass and spin its needle.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import * as three from 'three';\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, I chose to use three.js for rendering, TypeScript as the programming language, and WebPack. To set up your tools, you'll need to install node.js, NPM, and the following packages: typescript @types/three webpack webpack-cli webpack-dev-server. You'll then need to set up TypeScript and WebPack, but I personally just used a template I found online.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"this.scene = new three.Scene();\\r\\nthis.scene.background = new three.Color(\\\"gray\\\");\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, create a scene, where we'll place any lights, cameras, and objects. We'll also set the background color to gray. A colored background is useful for when the scene isn't working.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"this.camera = new three.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);\\r\\nthis.camera.position.z = 500;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The scene shouldn't be gray just yet, as a scene needs a camera.\"\n    }), \"\\n\", _jsx(\"video\", {\n      controls: true,\n      loop: true,\n      width: \"100%\",\n      children: _jsx(\"source\", {\n        src: \"/images/game-engine-graphics/ObviousInsidiousKestrel-mobile.mp4\",\n        type: \"video/mp4\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are 2 types you can choose from, perspective and orthographic.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/20211116174802_1.jpg\",\n      alt: \"\",\n      width: 1920,\n      height: 1080\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Perspective projection in Portal 2\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/IV_area2_back.PNG.png\",\n      alt: \"\",\n      width: 2048,\n      height: 2732\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Orthographic projection in Monument Valley\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With perspective projection, objects will appear smaller when they are farther away from the camera. Orthographic projection doesn't do this, and instead things will appear the same size no matter the distance away from the camera.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"//create the renderer\\r\\nthis.renderer = new three.WebGLRenderer();\\r\\nthis.renderer.setPixelRatio(window.devicePixelRatio);\\r\\ndocument.body.appendChild(this.renderer.domElement);\\r\\n\\r\\n//start animating\\r\\nthis.animate = this.animate.bind(this);\\r\\nwindow.requestAnimationFrame(this.animate);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"animate() {\\r\\n    window.requestAnimationFrame(this.animate);\\r\\n\\r\\n    this.renderer.render(this.scene, this.camera);\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We'll create a loop that'll animate our compass. In the loop, you call the renderer's render function and give it the scene and camera.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/gray_1.52.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Doing this correctly should give you a gray output.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const meshPromise = new Promise\u003cthree.Mesh\u003e((resolve, reject) =\u003e {\\r\\n    new three.TextureLoader().load('compass.png', (texture) =\u003e {\\r\\n        const geometry = new three.PlaneGeometry(600, 600);\\r\\n        const material = new three.MeshBasicMaterial( {map: texture } );\\r\\n\\r\\n        var mesh = new three.Mesh(geometry, material);\\r\\n\\r\\n        this.scene.add(mesh);\\r\\n        resolve(mesh);\\r\\n    })\\r\\n});\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now let's load in our mesh. \", _jsx(_components.a, {\n        href: \"/images/game-engine-graphics/compass.png\",\n        children: \"This is the texture file that we'll be using.\"\n      }), \" Loading a texture from a file will take an unknown amount of time, so you'll want to have it done in the background. The geometry and the material also needs to be defined. That'll be a plane, and the material should just output the color of our texture. Create the mesh using the geometry and material and add it to the sense.\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/load-mesh_1.56.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You should get a strange looking texture as a result.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is because the texture is repeated many times on the texture, and it mapped the corners of the tall image to the corners of our square.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"texture.repeat.set(1, 1/2);\\n\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/half-repeat_1.57.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To fix this, I set the texture's repeat vector. This allows textures to be repeated many times, but you can use a fraction to zoom in on the texture.\"\n    }), \"\\n\", _jsx(\"video\", {\n      controls: true,\n      loop: true,\n      width: \"100%\",\n      children: _jsx(\"source\", {\n        src: \"/images/game-engine-graphics/DangerousFoolhardyBadger-mobile.mp4\",\n        type: \"video/mp4\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const frameSize: number = 16/512; // same as 1/32\\r\\ntexture.repeat.set(1, this.frameSize);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, on the y-axis, we use 1 over how many times the compass is repeated on the texture.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/set-repeat_1.58.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The result should be a blurry compass.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/compass.jpg\",\n      alt: \"\",\n      width: 16,\n      height: 512\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The compass in Minecraft isn't blurry, it's pixelated.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"texture.magFilter = three.NearestFilter;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To get the same effect, change the magnification filter.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/magnification_1.62.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The magnification handles texture pixels that are bigger or the same size as a pixel on the screen.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/linear-mag_2.15.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The default is usually linear, which uses an average of the 4 closest pixels on the texture.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/nearest-mag_2.16.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To get the pixelated effect, we want to use the nearest pixel on the texture.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/set-meg-filter_1.66.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Resulting in a pixelated compass.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"material.alphaTest = 0.5;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's also remove the black background around the compass.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/color-picker_1.74.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 606\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Each pixel on the compass texture has 4 values, red, green, blue, and alpha. The alpha value goes from 0 for transparent, 1 for opaque, and around 0.5 for translucent.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/opacity_1.67.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For translucent material, they are given special treatment that lets them blend in with objects that are behind it. However, this blending can be slower to render and for this texture, the alpha values on this texture are either 0 or 1 because of nearest filtering. So, it makes sense for us to use an alpha text instead. Using an alpha test, makes the renderer ignore parts of the material where the alpha value is larger than the alpha test.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/alpha-test_1.78.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now you should see a compass on a gray background.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"this.frameNum += 1;\\r\\n(mesh.material as three.MeshBasicMaterial)?.map.offset.set(0, 1 - this.frameSize * this.frameNum);\\r\\nconst frameCount = 512/16;\\r\\nthis.frameNum = this.frameNum % frameCount;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With all that out of the way, let's start animating the compass.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/bottom-frame_2.20.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you look at which frame of the compass if being rendered, it's the one at the very bottom of the image.\"\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/game-engine-graphics/0-uv_2.21.1.jpg\",\n      alt: \"\",\n      width: 1280,\n      height: 720\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is because 0 in our UV map is on the bottom left.\"\n    }), \"\\n\", _jsx(\"video\", {\n      controls: true,\n      loop: true,\n      width: \"100%\",\n      children: _jsx(\"source\", {\n        src: \"/images/game-engine-graphics/SelfishAgonizingAllensbigearedbat-mobile.mp4\",\n        type: \"video/mp4\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, using an offset of 1 - 1/32 gives the first frame. The 2nd frame would be 1 - (1/32 * 2). Giving us the formula 1 - (frameSize * frameNum), with frameNum being set to frameNum + 1 every time we render. You might also need to loop the frameNum back to 1, when it gets higher than the number of frames available, to allow for a looping animation and this can be done with % or modulo.\"\n    }), \"\\n\", _jsx(\"video\", {\n      controls: true,\n      loop: true,\n      width: \"100%\",\n      children: _jsx(\"source\", {\n        src: \"/images/game-engine-graphics/FlimsyGaseousChanticleer-mobile.mp4\",\n        type: \"video/mp4\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"And we're done. \", _jsx(_components.a, {\n        href: \"https://github.com/yourWaifu/game-engine/blob/16f7d3059797f87ea6351b755cd719f38f48c97f/js/index.ts\",\n        children: \"Here's the final code.\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you have any question, please feel free to do so in the comments. I'll make a part 2 if this content becomes successful and has lots of likes or claps.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"layout":"article","title":"Video Game Graphics - Make a Game Engine","description":null,"author":"Hao Qi Wu","date":"Mon Nov 29 2021 22:30:00 GMT+0000 (Coordinated Universal Time)"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"game-engine-graphics"},"buildId":"36ahIlKQJ3GJD0QPJ4a2T","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>